Реализован интерпретатор модельного языка.
Описание языка
〈программа〉 → program { 〈описания〉 〈операторы〉 }
〈описания〉 → { 〈описание〉; }
〈описание〉 → 〈тип〉 〈переменная〉 { , 〈переменная〉 }
〈тип〉 → int | string
〈переменная〉 → 〈идентификатор〉 |
〈идентификатор〉 = 〈константа〉
〈константа〉 → 〈целочисленная〉 | 〈строковая〉
〈целочисленная〉 → [〈знак〉] 〈цифра〉 { 〈цифра〉 }
〈знак〉 → + | −
〈строковая〉 → " { 〈литера〉 } "
〈операторы〉 → { 〈оператор〉 }
〈оператор〉 → if (〈выражение〉) 〈оператор〉 else 〈оператор〉 |
while (〈выражение〉) 〈оператор〉|
read (〈идентификатор〉); |
write (〈выражение〉 { , 〈выражение〉 } ); |
〈составной оператор〉 | 〈оператор-выражение〉
〈составной оператор〉 → { 〈операторы〉 }
〈оператор-выражение〉 → 〈выражение〉;

Используются классы:
Lex - лексема.
В классе Lex находится static vector<Ident> TID - таблица идентификаторов.
Ident - идентификатор.
Scanner - работает с файлом программы и таблицами служебных слов и разделителей.
Parser - осуществляет синтаксический и семантический этап.
В классе Parser находится vector<Lex> poliz - вектор, который хранит полиз программы.
Executer - осуществляет выполнение команды с помощью полиза.
Interpretator - объединяет этапы обработки программы.

Лексический анализ:
Lex Scanner::get_lex() - выделяет лексему и возвращает её. Пропускает пробелы, твбуляции и перевод строки, считает переводы строк в переменную класса Lex static int numb_of_str для вывода номера
строки, в которой встретится ошибка.

Синтаксический анализ:
Методом рекурсивного спуска с помощью методов класса Parser:
void analyze(); - вызывает P() и после выхода из рекурсии печатает полученный полиз
void P(); - проверяет наличие слова program и вызывает B()
void D(type_of_lex); - обработка объявления переменных, записывает идентификаторы в TID и инициализирует их, если нужно
void B(); - обработка операторов
void S(); - обработка конструкций описаний, if, while, write, read, записывает их в полиз
void E(); - обработка выражений
void E1(); void T(); void F(); - обработка идентификаторов, констант и знаков, запись их в полиз
E(), E1(), T(), F() выполняют часть семантичяеского анализа, проверяя правильность операций и опперандов

Семантический анализ:
void dec ( type_of_lex type); - объявление переменной
void check_id (); - проверка объявления идентификатора
void check_op (); - проверка типов операндов
void check_not (); - проверка not
void eq_type (); - проверка совпадения типов в присваивании
void eq_bool (); - проверка выражения на тип bool
void check_id_in_read (); - проверка, объявлен ли идентификатор

Выполнение:
Осуществляется методом построения ПОЛИЗа на этапе синтаксического и семантического анализов.
void Execute:executer(vector <Lex> & poliz) - достаёт лексемы из полиза и выполняет программу.
poliz - построен на этапе синтаксического и семантического анализов. В цикле просматриваются все лексемы в полизе. Если это адресс переменной, метка, число или строка, то они записываются в тек stack<Lex> arglex.
Если это not, or, and, go, Fgo, +, *, -, /, ==, >=, <=, >, <, то из arglex достаются последние лексемы, над ними производится нужная операция и результат кладётся обратно в arglex.
Если это = или read, то из arglex достаётся лексема и для идентификатора, соответствующему этой лексеме, происходит нужное действие с TID.

Класс Interpretator содержит объект класса Parser и Executer и метод interpretation.
В main создаётся объект класса Interpretator с названием файла, в котором находится программма. Для объекта вызывается метод interpretation, в котором для объекта класса Parser вызывается метод analyze(), который
запускает синтаксический и семантический анализ, затем для объекта класса Executer вызывается метод c параметром vector<Lex> poliz, который был построен на синтаксическом и семантическом анализе. В случае возникновения ошибки
на каждом из этапов печатается номер строки, где произошла ошибка, и выбрасывается с помощью throw причина ошибки.
